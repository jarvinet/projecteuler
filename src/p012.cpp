#include <iostream>
#include <vector>
#include <map>
#include <time.h>

/*
Problem 12

   08 March 2002

   The sequence of triangle numbers is generated by adding the natural numbers. So the 7 ^(
   ^th ) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would
   be:

   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

   Let us list the factors of the first seven triangle numbers:

      1: 1
      3: 1,3
      6: 1,2,3,6
     10: 1,2,5,10
     15: 1,3,5,15
     21: 1,3,7,21
     28: 1,2,4,7,14,28

   We can see that 28 is the first triangle number to have over five divisors.

   What is the value of the first triangle number to have over five hundred divisors?
*/

/*

28 = 2 * 2 * 7 = 2^2 * 7^1
divisors(28) = 1 2 4 7 14 28
number of divisors = D(28) = 6
d(28) = (e1+1)*(e2+1) = (2+1)*(1+1) = 3*2 = 6

find prime factorisation
28 = 2 * 2 * 7
find exponents
28 = 2^2 * 7^1

*/


typedef unsigned long long ValueType;

std::vector<ValueType> findDivisors(ValueType n)
{
    std::vector<ValueType> divisors;

    for (ValueType i = 1; i <= n; i++)
        if ((n % i) == 0) {
            divisors.push_back(i);
        }

    return divisors;
}

bool isDivisible(ValueType n, std::vector<ValueType> primes)
{
    for (int i = 0, sz = primes.size(); i < sz; i++) {
        ValueType prime = primes[i];
        if (prime*prime > n)
            break;
        if ((n % primes[i]) == 0)
            return true;
    }
    return false;
}

// return a vector of n first primes
// uses sieve of eratosthenes
std::vector<ValueType> eratosthenes(ValueType n)
{
    std::vector<ValueType> primes;

    for (ValueType i = 2; primes.size() < n; i++)
        if (!isDivisible(i, primes))
            primes.push_back(i);
    return primes;
}


std::vector<ValueType> primeFactors(ValueType n, std::vector<ValueType> primes)
{
    std::vector<ValueType> factors;

    for (int i = 0, sz = primes.size(); i < sz; ++i) {
        ValueType prime = primes[i];
        if (prime > n)
            break;
        if ((n % prime) == 0) {
            factors.push_back(prime);
            ValueType m = n/prime;
            std::vector<ValueType> factors2 = primeFactors(m, primes);
            factors.insert(factors.end(), factors2.begin(), factors2.end());
            break;
        }
    }

    return factors;
}

int numDivisors(std::vector<ValueType> factors)
{
    // map a factor to how many times it occurs in factors
    std::map<int,int> m;

    for (int i = 0, sz = factors.size(); i < sz; ++i) {
        ValueType factor = factors[i];
        std::map<int,int>::iterator i = m.find(factor);
        if (i == m.end()) {
            m.insert(std::make_pair(factor, 1));
        } else {
            m[factor] += 1;
        }
    }

    int res = 1;
    for (std::map<int,int>::iterator i = m.begin(); i != m.end(); ++i) {
        res *= (i->second + 1);
    }
    return res;
}

void print(std::vector<ValueType> v)
{
    for (int i = 0, sz = v.size(); i < sz; ++i) {
        std::cout << v[i] << " ";
    }
    std::cout << "\n";
}

int main()
{
    std::vector<ValueType> primes = eratosthenes(100);

    ValueType trangularNumber = 0;

    for (ValueType i = 1; i < 99999; i++) {
        trangularNumber += i;
        std::vector<ValueType> factors = primeFactors(trangularNumber, primes);
        int nDiv = numDivisors(factors);
        if (nDiv > 500) {
            std::cout << trangularNumber << "\n";
            break;
        }
    }
}
